#本文作者：玉树临风
#正则表达式在网页源码中查找一些特定的信息非常重要，玉树临风是“空间刷刷”的作者，很厉害啊！
#tengge仅作少量修改…
#先提示下用法，免得学起来枯燥无味…
import re
#引入正则表达式模块
p=re.compile("[\w]*",re.I)
#参数一是正则表达式，参数二是编译标志，参数二可省略
#剩下的就是匹配了，大家去看第二节…

最重要的是正则表达式的创建，我们创建好正则表达式后，再用它在数据中查找想匹配的信息。

1.匹配

元字符是"["和"]"。它们常用来指定一个字符类别，所谓字符类别就是你想匹配的一个字符集。字符可以单个列出，也可以用“-”号分隔的两个给定字符来表示一个字符区间。例如，[abc] 将匹配"a","b", 或"c"中的任意一个字符；也可以用区间[a-c]来表示同一字符集，和前者效果一致。元字符在类别里并不起作用。

你可以用补集来匹配不在区间范围内的字符。其做法是把"^"作为类别的首个字符；其它地方的"^"只会简单匹配"^"字符本身。

也许最重要的元字符是反斜杠"\"。 做为 Python 中的字符串字母，反斜杠后面可以加不同的字符以表示不同特殊意义。它也可以用于取消所有的元字符，这样你就可以在模式中匹配它们了。

下列是可用的预设特殊字符：
\d
匹配任何十进制数；它相当于类 [0-9]。
\D
匹配任何非数字字符；它相当于类 [^0-9]。
\s
匹配任何空白字符；它相当于类
[ \t\n\r\f\v]。
\S
匹配任何非空白字符；它相当于类 [^ \t\n\r\f\v]。
\w
匹配任何字母数字字符；它相当于类 [a-zA-Z0-9_]。
\W
匹配任何非字母数字字符；它相当于类 [^a-zA-Z0-9_]。
这样特殊字符都可以包含在一个字符类中。

本节最后一个元字符是 . 。它匹配除了换行字符外的任何字符，在 alternate 模式（re.DOTALL）下它甚至可以匹配换行。"."通常被用于你想匹配“任何字符”的地方。

2.重复

正则表达式第一件能做的事是能够匹配不定长的字符集，而这是其它能作用在字符串上的方法所不能做到的。 不过，如果那是正则表达式唯一的附加功能的话，那么它们也就不那么优秀了。它们的另一个功能就是你可以指定正则表达式的一部分的重复次数。

* 并不匹配字母字符"*"；相反，它指定前一个字符可以被匹配零次或更多次，而不是只有一次。

象 * 这样地重复是“贪婪的”；当重复一个 RE 时，匹配引擎会试着重复尽可能多的次数。如果模式的后面部分没有被匹配，匹配引擎将退回并再次尝试更小的重复。

另一个重复元字符是 +，表示匹配一或更多次。

问号 ? 匹配一次或零次；你可以认为它用于标识某事物是可选的。

最复杂的重复限定符是 {m,n}，其中 m 和 n 是十进制整数。该限定符的意思是至少有 m 个重复，至多到 n 个重复。

例如，"a[\\d]{2,3}b"匹配以a开头，以b结尾，中间有至少2个整数，至多三个整数的字符串。:)一定注意有两个斜杠，一个是字符串的转义符，另一个是正则表达式的转义符。


在字符串前加个"r"反斜杠就不会被任何特殊方式处理，

3.执行匹配（建议不要看）

match() 决定 RE 是否在字符串刚开始的位置匹配

search() 扫描字符串，找到这个 RE 匹配的位置

findall() 找到 RE 匹配的所有子串，并把它们作为一个列表返回

finditer() 找到 RE 匹配的所有子串，并把它们作为一个迭代器返回

如果没有匹配到的话，match() 和 search() 将返回 None。如果成功的话，就会返回一个 `MatchObject` 实例，其中有这次匹配的信息：它是从哪里开始和结束，它所匹配的子串等等。

现在你可以查询 `MatchObject` 关于匹配字符串的相关信息了。MatchObject 实例也有几个方法和属性；最重要的那些如下所示：
方法/属性 作用

group() 返回被 RE 匹配的字符串

start() 返回匹配开始的位置

end() 返回匹配结束的位置

span() 返回一个元组包含匹配 (开始,结束) 的位置

4.编译标志：
这有个可用标志表，对每个标志后面都有详细的说明。
标志 含义

DOTALL, S 使 . 匹配包括换行在内的所有字符（即re.S）

IGNORECASE, I 使匹配对大小写不敏感（即re.I）

LOCALE, L做本地化识别（locale-aware）匹配(即re.L)

MULTILINE, M 多行匹配，影响 ^ 和 $（即re.M）

VERBOSE, X 能够使用 REs 的 verbose 状态，使之被组织得更清晰易懂(及re.X)

I
IGNORECASE
使匹配对大小写不敏感；字符类和字符串匹配字母时忽略大小写。举个例子，[A-Z]也可以匹配小写字母，Spam 可以匹配"Spam","spam", 或"spAM"。这个小写字母并不考虑当前位置。
L
LOCALE
影响 \w, \W, \b, 和 \B，这取决于当前的本地化设置。
locales 是 C 语言库中的一项功能，是用来为需要考虑不同语言的编程提供帮助的。举个例子，如果你正在处理法文文本，你想用 \w+ 来匹配文字，但 \w 只匹配字符类 [A-Za-z]；它并不能匹配"é"或"?"。如果你的系统配置适当且本地化设置为法语，那么内部的 C 函数将告诉程序"é"也应该被认为是一个字母。当在编译正则表达式时使用 LOCALE 标志会得到用这些 C 函数来处理 \w 后的编译对象；这会更慢，但也会象你希望的那样可以用 \w+ 来匹配法文文本。
M
MULTILINE此时 ^ 和 $ 不会被解释