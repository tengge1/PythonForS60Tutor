#本文作者：玉树临风
#看不懂没关系，去看第二节，tengge写的正则表达式教程。。。

1.匹配

元字符是"["和"]"。它们常用来指定一个字符类别，所谓字符类别就是你想匹配的一个字符集。字符可以单个列出，也可以用“-”号分隔的两个给定字符来表示一个字符区间。例如，[abc] 将匹配"a","b", 或"c"中的任意一个字符；也可以用区间[a-c]来表示同一字符集，和前者效果一致。元字符在类别里并不起作用。

你可以用补集来匹配不在区间范围内的字符。其做法是把"^"作为类别的首个字符；其它地方的"^"只会简单匹配"^"字符本身。

也许最重要的元字符是反斜杠"\"。 做为 Python 中的字符串字母，反斜杠后面可以加不同的字符以表示不同特殊意义。它也可以用于取消所有的元字符，这样你就可以在模式中匹配它们了。

下列是可用的预设特殊字符：
\d
匹配任何十进制数；它相当于类 [0-9]。
\D
匹配任何非数字字符；它相当于类 [^0-9]。
\s
匹配任何空白字符；它相当于类
[ \t\n\r\f\v]。
\S
匹配任何非空白字符；它相当于类 [^ \t\n\r\f\v]。
\w
匹配任何字母数字字符；它相当于类 [a-zA-Z0-9_]。
\W
匹配任何非字母数字字符；它相当于类 [^a-zA-Z0-9_]。
这样特殊字符都可以包含在一个字符类中。

本节最后一个元字符是 . 。它匹配除了换行字符外的任何字符，在 alternate 模式（re.DOTALL）下它甚至可以匹配换行。"."通常被用于你想匹配“任何字符”的地方。

2.重复

正则表达式第一件能做的事是能够匹配不定长的字符集，而这是其它能作用在字符串上的方法所不能做到的。 不过，如果那是正则表达式唯一的附加功能的话，那么它们也就不那么优秀了。它们的另一个功能就是你可以指定正则表达式的一部分的重复次数。

* 并不匹配字母字符"*"；相反，它指定前一个字符可以被匹配零次或更多次，而不是只有一次。

象 * 这样地重复是“贪婪的”；当重复一个 RE 时，匹配引擎会试着重复尽可能多的次数。如果模式的后面部分没有被匹配，匹配引擎将退回并再次尝试更小的重复。

另一个重复元字符是 +，表示匹配一或更多次。

问号 ? 匹配一次或零次；你可以认为它用于标识某事物是可选的。

最复杂的重复限定符是 {m,n}，其中 m 和 n 是十进制整数。该限定符的意思是至少有 m 个重复，至多到 n 个重复。

解决的办法就是为正则表达式使用 Python 的 raw 字符串表示；在字符串前加个"r"反斜杠就不会被任何特殊方式处理，

3.执行匹配

match() 决定 RE 是否在字符串刚开始的位置匹配

search() 扫描字符串，找到这个 RE 匹配的位置

findall() 找到 RE 匹配的所有子串，并把它们作为一个列表返回

finditer() 找到 RE 匹配的所有子串，并把它们作为一个迭代器返回

如果没有匹配到的话，match() 和 search() 将返回 None。如果成功的话，就会返回一个 `MatchObject` 实例，其中有这次匹配的信息：它是从哪里开始和结束，它所匹配的子串等等。

现在你可以查询 `MatchObject` 关于匹配字符串的相关信息了。MatchObject 实例也有几个方法和属性；最重要的那些如下所示：
方法/属性 作用

group() 返回被 RE 匹配的字符串

start() 返回匹配开始的位置

end() 返回匹配结束的位置

span() 返回一个元组包含匹配 (开始,结束) 的位置

